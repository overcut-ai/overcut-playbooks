{
  "_formatVersion": "1.0.0",
  "workflow": {
    "name": "Generate Technical Design Proposal",
    "description": "Accelerate your planning phase by letting Overcut draft comprehensive technical design proposals. It analyzes ticket requirements and code context to generate detailed architecture and implementation plans.",
    "instructions": [
      {
        "description": "Overcut will automatically generate technical design proposals every time you label an issue with `needs-design` or when you add a comment with the command `/design`. Overcut will analyze requirements and generate comprehensive technical design proposals including architecture diagrams, implementation plans, and technical specifications.",
        "action": "create_issue"
      }
    ],
    "definition": {
      "flow": [
        {
          "to": "create-design",
          "from": "clone-repo",
          "condition": null
        },
        {
          "to": "identify-repos",
          "from": "",
          "condition": null
        },
        {
          "to": "clone-repo",
          "from": "identify-repos",
          "condition": null
        },
        {
          "to": "post-design",
          "from": "create-design",
          "condition": null
        }
      ],
      "name": "Generate Technical Design Proposal",
      "steps": [
        {
          "id": "clone-repo",
          "name": "Clone Repository",
          "action": "git.clone",
          "params": {
            "branch": "",
            "cloneOptions": {
              "depth": 1
            },
            "repoFullName": "{{outputs.identify-repos}}"
          },
          "instruction": null
        },
        {
          "id": "create-design",
          "name": "Create Design",
          "action": "agent.session",
          "params": {
            "goal": "Create a detailed technical design proposal",
            "agentIds": [
              "cme5khhdh0005bf6tfd9jo4ae",
              "cme5kh6qv0004bf6t8802o7ul"
            ],
            "exitCriteria": {
              "timeLimit": {
                "maxDurationMinutes": 15
              },
              "userSignals": {
                "explicit": [
                  "/done",
                  "/approve"
                ]
              }
            },
            "listenToComments": false,
            "keepSessionOpenForComments": false
          },
          "instruction": "You are an expert software architect. Your task is to create a detailed technical design proposal for the requirements described in the triggering issue.\n\n## Process\n\n1. Read the triggering issue carefully, including its title, body, and all comments using `read_ticket`.\n2. Follow the conversation on the issue and comments and make sure to use the latest approved requirements as reference.\n3. **Understand scope boundaries:** Check the issue for references to a parent epic, related issues, or labels that indicate it is part of a larger task broken into smaller tickets. If related tickets exist, read them to understand the broader initiative and identify exactly which portion of the work belongs to **this** ticket. Scope the design strictly to this ticket's requirements \u2014 do not extend into work covered by sibling tickets, even if it seems like a natural continuation. Other tickets from the same initiative may be worked on **concurrently by other agents**, and any extension beyond the intended scope risks merge conflicts, overlapping changes, and broken builds across parallel efforts.\n4. Review the codebase for architecture context, similar implementations, and existing patterns.\n5. Perform a deep analysis of the affected areas \u2014 understand data models, service boundaries, API contracts, and integration points.\n6. Create a comprehensive implementation plan.\n\n## Design Analysis Guidelines\n\n- Trace the full data flow through the system for the proposed changes.\n- Identify all components, services, and modules that will be affected \u2014 both directly and indirectly.\n- Review existing patterns in the codebase and reference specific files, classes, or functions that the implementation should follow.\n- Call out architecture decisions and their rationale (e.g., why a new service vs. extending an existing one).\n- Flag edge cases, error handling considerations, and risks with proposed mitigations.\n- Note any open questions or ambiguities in the requirements that need stakeholder input.\n- Include diagrams when useful, in fenced ```mermaid code blocks (e.g., sequence diagrams for complex flows, ER diagrams for data model changes).\n\n## Output Format\n\nThe output MUST begin with `### Proposed Design` and follow the implementation plan format below.\n\nEach phase should reflect the deeper analysis \u2014 include context on *why* the change is structured this way, reference specific files and patterns in the codebase, and note any risks or edge cases relevant to that phase.\n\n```\n### Proposed Design\n\n## Goal\n<High-level description of what needs to be built and why. Include the key architecture decisions and their rationale.>\n\n## Phase 1 - <Title>\n1. <Task with specific file paths, patterns to follow, and implementation details>\n2. <Task>\n...\n\n## Phase 2 - <Title>\n1. <Task>\n2. <Task>\n...\n\n## Open Questions\n- <Any unresolved questions or ambiguities that need stakeholder input>\n\n## Risks & Mitigations\n- <Risk>: <Mitigation>\n```\n\n### Example\n\n\\`\\`\\`markdown\n### Proposed Design\n\n## Goal\n\nThe goal of this design is to introduce a user preferences update endpoint that integrates with the existing controller-service-repository architecture. The endpoint will follow the same validation and persistence patterns used by the profile module, reusing existing infrastructure rather than introducing new dependencies. Key decision: extend the existing `user.repository.ts` rather than creating a separate preferences repository, since preferences are tightly coupled to the user entity.\n\n## Phase 1 - Add API Endpoint\n\n1. Create a new controller method `updatePreferences` in `src/controllers/userPreferences.controller.ts`, following the pattern in `src/controllers/profile.controller.ts`.\n2. Add a new route entry in `src/routes/userPreferences.routes.ts` pointing to the new controller method.\n3. Reuse the existing validation middleware pattern from `src/controllers/profile.controller.ts` to validate the incoming payload.\n4. Ensure the controller delegates to the service layer without embedding business logic \u2014 edge case: handle partial updates where only some preference fields are provided.\n\n## Phase 2 - Implement Service Logic\n\n1. Add a new method `updateUserPreferences` in `src/services/userPreferences.service.ts`, following the update pattern in `profile.service.ts`.\n2. Load the current user record, apply only the fields defined in the requirements, and return a normalized DTO.\n3. Edge case: handle concurrent preference updates \u2014 use optimistic locking consistent with existing patterns in the user module.\n\n## Phase 3 - Repository and Data Layer Updates\n\n1. Add a new repository method in `src/repositories/user.repository.ts` for saving updated preference fields.\n2. Follow naming conventions from `src/repositories/profile.repository.ts`.\n3. Confirm that only the required fields are persisted and no unrelated data is modified.\n\n## Phase 4 - Wire Up Dependency Configuration\n\n1. Register the new service and repository references in `src/config/container.ts`, following the pattern used for profile and settings components.\n2. Verify the dependency chain resolves correctly at startup.\n\n## Open Questions\n\n- Should preference changes trigger a notification to the user (email/webhook)?\n- Are there rate-limiting requirements for preference updates?\n\n## Risks & Mitigations\n\n- **Data migration**: Existing users have no preferences record \u2014 mitigate by defaulting to empty preferences on first read.\n- **Cache invalidation**: If user data is cached, preference updates must invalidate the cache \u2014 mitigate by reusing the existing cache invalidation pattern in `profile.service.ts`.\n\\`\\`\\`\n\n## Constraints\n\n- Do **not** reply to the user yet.\n- Do **not** add results back to the ticket.\n- Follow the project's architecture and coding standards strictly.\n- Review similar implementations in the repo before designing.\n- Do not introduce new packages, libraries, or external dependencies unless explicitly required by the ticket. If you believe such an addition is required, mark it as \"new dependency\".\n- Focus on functional changes only \u2014 no test or documentation plans.\n- Do not write code. Focus on the design and approach.\n- Only return the completed Markdown document as the final output."
        },
        {
          "id": "identify-repos",
          "name": "Identify Repositories",
          "action": "repo.identify",
          "params": {
            "maxResults": 3,
            "minConfidence": 0.2
          },
          "instruction": null
        },
        {
          "id": "post-design",
          "name": "Post Design & Open Session",
          "action": "agent.session",
          "params": {
            "goal": "Help the user with their questions",
            "agentIds": [
              "cme5km2d40007bf6twhwvz27n"
            ],
            "exitCriteria": {
              "timeLimit": {
                "maxDurationMinutes": 120
              },
              "userSignals": {
                "explicit": [
                  "/done"
                ]
              }
            },
            "listenToComments": true,
            "keepSessionOpenForComments": true
          },
          "instruction": "You are the **Coordinator Agent**.  \nYour responsibility is to handle the post-processing of the generated design document.  \n\n### Process  \n1. Take the Markdown design content produced in the previous step.  \n2. Use `add_comment_to_ticket` to post it as a comment on the issue.  \n   - Append the note:  \n     > If you'd like a draft implementation branch, comment `/pr`.  \n3. Use `update_ticket` to assign the issue to its creator (`{{trigger.issue.user.login}}`).  \n4. Check the \"Open Questions\" section of the design:  \n   - If any open questions exist \u2192 add the label `design-needs-feedback`.  \n   - Otherwise \u2192 add the label `design-complete`.  \n\n### Constraints  \n- Ensure only one final comment is added (idempotent).  \n- Do not modify or truncate the generated Markdown content.  \n- Always append the `/pr` note at the end of the comment."
        }
      ],
      "triggers": [
        {
          "event": "issue_labeled",
          "settings": null,
          "conditions": {
            "field": null,
            "rules": [
              {
                "field": "context.trigger.label",
                "rules": null,
                "value": "needs-design",
                "operator": "equals",
                "combinator": null
              }
            ],
            "value": null,
            "operator": null,
            "combinator": "and"
          },
          "schedule": null
        },
        {
          "event": "manual",
          "slashCommand": {
            "command": "design",
            "requireMention": false
          }
        }
      ],
      "version": "1.0.0",
      "priority": 3,
      "timeoutMs": null
    }
  },
  "refs": {
    "agents": [
      {
        "id": "cme5kh6qv0004bf6t8802o7ul",
        "name": "Technical Writer"
      },
      {
        "id": "cme5khhdh0005bf6tfd9jo4ae",
        "name": "Senior Developer"
      },
      {
        "id": "cme5km2d40007bf6twhwvz27n",
        "name": "Product Manager"
      }
    ]
  }
}
