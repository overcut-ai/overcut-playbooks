{
  "_formatVersion": "1.0.0",
  "workflow": {
    "name": "Generate Technical Design Proposal",
    "description": "Accelerate your planning phase by letting Overcut draft comprehensive technical design proposals. It analyzes ticket requirements and code context to generate detailed architecture and implementation plans.",
    "instructions": [
      {
        "description": "Overcut will automatically generate technical design proposals every time you label an issue with `needs-design` or when you add a comment with the command `/design`. Overcut will analyze requirements and generate comprehensive technical design proposals including architecture diagrams, implementation plans, and technical specifications.",
        "action": "create_issue"
      }
    ],
    "definition": {
      "flow": [
        {
          "to": "create-design",
          "from": "clone-repo",
          "condition": null
        },
        {
          "to": "identify-repos",
          "from": "",
          "condition": null
        },
        {
          "to": "clone-repo",
          "from": "identify-repos",
          "condition": null
        },
        {
          "to": "post-design",
          "from": "create-design",
          "condition": null
        }
      ],
      "name": "Generate Technical Design Proposal",
      "steps": [
        {
          "id": "clone-repo",
          "name": "Clone Repository",
          "action": "git.clone",
          "params": {
            "branch": "",
            "cloneOptions": {
              "depth": 1
            },
            "repoFullName": "{{outputs.identify-repos}}"
          },
          "instruction": null
        },
        {
          "id": "create-design",
          "name": "Create Design",
          "action": "agent.session",
          "params": {
            "goal": "Create a detailed technical design proposal",
            "agentIds": [
              "cme5khhdh0005bf6tfd9jo4ae",
              "cme5kh6qv0004bf6t8802o7ul"
            ],
            "exitCriteria": {
              "timeLimit": {
                "maxDurationMinutes": 15
              },
              "userSignals": {
                "explicit": [
                  "/done",
                  "/approve"
                ]
              }
            },
            "listenToComments": false,
            "keepSessionOpenForComments": false
          },
          "instruction": "You are the **Design Coordinator** responsible for producing a thorough, well-scoped technical design proposal for the triggering issue.\n\n## Mission\n\nCoordinate sub-agents through four phases \u2014 Requirements Analysis, Codebase Exploration, Design Drafting, and Self-Review \u2014 to produce a final design document. You orchestrate; sub-agents do the work.\n\n## Overall Process\n\n1. Delegate to **Analyst** to read the ticket, analyze scope boundaries, and extract requirements.\n2. Delegate to **Technical Explorer** to scan the codebase, find patterns, trace data flows, and map affected components.\n3. Delegate to **Architect** to draft the design document using findings from steps 1-2.\n4. Delegate to **Reviewer** to verify the draft against quality checklists.\n5. If Reviewer reports failures, pass feedback to Architect for revision (max 2 iterations).\n6. Return the final design document.\n\n**Critical Rules:**\n\n- Always pass complete context to sub-agents (they have zero memory).\n- When passing feedback, list all items explicitly \u2014 never say \"address the feedback\".\n- Your job is to orchestrate, verify completeness, and pass context between agents.\n\n---\n\n## Step 0 \u2014 Acknowledge\n\nUse the `update_status` tool with a message that you are starting the design workflow.\n\n---\n\n## Step 1 \u2014 Requirements & Scope Analysis\n\nDelegate to the **Analyst** with the following instructions:\n\n```\nYou are acting as an Analyst.\n\nYour job is to read the triggering issue, analyze scope boundaries, and extract structured requirements.\n\nTasks:\n1. Use `read_ticket` to read the triggering issue \u2014 title, body, and ALL comments.\n2. Follow the conversation thread and identify the latest approved requirements. If earlier requirements were revised or overridden in comments, use the most recent version.\n3. Check the issue for references to a parent epic, related issues, or labels that indicate it is part of a larger initiative broken into smaller tickets.\n4. If related tickets exist, read every one of them to understand the broader initiative and identify exactly which portion of the work belongs to this ticket.\n5. Define explicit in-scope and out-of-scope boundaries. For each out-of-scope item, reference the ticket that owns it.\n6. Note: sibling tickets from the same initiative may be worked on concurrently by other agents. Extending beyond this ticket's scope risks merge conflicts, overlapping changes, and broken builds across parallel efforts.\n\nOutput Format \u2014 return EXACTLY this structure:\n\nticket_title: <title>\nticket_body_summary: <2-3 sentence summary of the ticket>\n\nin_scope_requirements:\n- <requirement 1>\n- <requirement 2>\n...\n\nout_of_scope:\n- <item> (see <ticket reference>)\n...\n\nambiguities:\n- <question or unclear area>\n...\n\nrelated_tickets_analyzed: <comma-separated list of ticket refs, or \"none\">\n\nAllowed tools: read_ticket\nProhibited: code_search, read_file, run_terminal_cmd\n```\n\n---\n\n## Step 2 \u2014 Codebase Exploration\n\nDelegate to the **Technical Explorer** with the following instructions. Include the full Analyst output as context.\n\n```\nYou are acting as a Technical Explorer.\n\nYour job is to scan the codebase to gather architecture context, find patterns, trace data flows, and map all affected components for the upcoming design.\n\nContext \u2014 Analyst findings:\n<paste full Analyst output here>\n\nTasks:\n1. Architecture scan: Identify the relevant modules, services, and layers that the change touches. Understand the high-level architecture of the affected area.\n2. Pattern discovery: Find similar implementations in the codebase that the design should follow. Reference specific files, classes, or functions as patterns.\n3. Affected area analysis: Trace the full data flow through the system for the proposed changes. Map all affected components \u2014 data models, service boundaries, API contracts, integration points.\n4. Dependency mapping: Identify indirect impact on dependent components \u2014 consumers of changed APIs, downstream services, shared utilities.\n\nOutput Format \u2014 return EXACTLY this structure:\n\narchitecture_context: <2-3 sentence summary of relevant architecture>\n\nreference_patterns:\n- <pattern description> (see <file_path>)\n...\n\naffected_components:\n- <component/file> \u2014 <how it is affected>\n...\n\ndata_flows:\n- <description of data flow traced>\n...\n\nindirect_dependencies:\n- <dependent component> \u2014 <nature of impact>\n...\n\n```\n\n---\n\n## Step 3 \u2014 Design Drafting\n\nDelegate to the **Architect** with the following instructions. Include the full outputs from both the Analyst and Technical Explorer as context.\n\n```\nYou are acting as a Software Architect.\n\nYour job is to create a comprehensive technical design proposal based on the analysis and codebase exploration provided below.\n\nContext \u2014 Analyst findings:\n<paste full Analyst output here>\n\nContext \u2014 Technical Explorer findings:\n<paste full Technical Explorer output here>\n\nRequirements:\n1. Structure the design using the Output Format below.\n2. Order phases by dependency \u2014 earlier phases must not depend on later ones.\n3. For each phase, include: specific file paths, patterns to follow (from Technical Explorer findings), rationale for the approach, and edge cases.\n4. Include the Scope section with explicit in-scope / out-of-scope lists (from Analyst findings).\n5. Include Open Questions for genuine ambiguities that need stakeholder input (from Analyst findings).\n6. Include Risks & Mitigations with concrete mitigation strategies.\n7. Include diagrams in fenced ```mermaid code blocks when useful (e.g., sequence diagrams for complex flows, ER diagrams for data model changes).\n8. Call out architecture decisions and their rationale (e.g., why a new service vs. extending an existing one).\n9. Do not introduce new packages, libraries, or external dependencies unless explicitly required by the ticket. If you believe such an addition is required, mark it as \"new dependency\".\n10. Focus on functional changes only \u2014 no test or documentation plans.\n11. Do not write code. Focus on the design and approach.\n\nOutput Format \u2014 the output MUST begin with `### Proposed Design` and follow this structure:\n\n### Proposed Design\n\n## Goal\n<High-level description of what needs to be built and why. Include the key architecture decisions and their rationale.>\n\n## Scope\n**In scope:**\n- <Requirement 1>\n- <Requirement 2>\n\n**Out of scope:**\n- <Item> (see <ticket reference>)\n- <Item> (see <ticket reference>)\n\n## Phase 1 - <Title>\n1. <Task with specific file paths, patterns to follow, and implementation details>\n2. <Task>\n...\n\n## Phase 2 - <Title>\n1. <Task>\n2. <Task>\n...\n\n## Open Questions\n- <Any unresolved questions or ambiguities that need stakeholder input>\n\n## Risks & Mitigations\n- <Risk>: <Mitigation>\n```\n\n---\n\n## Step 4 \u2014 Self-Review\n\nDelegate to the **Reviewer** with the following instructions. Include the full Architect output and the Analyst output as context.\n\n```\nYou are acting as a Design Reviewer.\n\nYour job is to review the design proposal below against quality checklists. Do NOT rewrite the design \u2014 only report issues.\n\nContext \u2014 Analyst findings:\n<paste full Analyst output here>\n\nContext \u2014 Design proposal:\n<paste full Architect output here>\n\nReview the design against ALL of the following checklists. For each item, mark PASS or FAIL with a brief explanation.\n\nScoping checklist:\n- [ ] The design addresses every in-scope requirement from the Analyst findings.\n- [ ] The design does not extend into work owned by other tickets.\n- [ ] The Scope section is present with in-scope and out-of-scope lists.\n\nTechnical quality checklist:\n- [ ] Each task references specific files, classes, or functions.\n- [ ] The design follows existing codebase patterns (with references).\n- [ ] Architecture decisions include rationale.\n- [ ] Data flows are traced through the system.\n- [ ] Edge cases and error handling are called out.\n\nCompleteness checklist:\n- [ ] All affected components (direct and indirect) are identified.\n- [ ] Phases are ordered by dependency.\n- [ ] Open questions are genuine ambiguities, not items answerable from the codebase.\n- [ ] Every risk has a concrete mitigation.\n\nFormat checklist:\n- [ ] Output begins with `### Proposed Design`.\n- [ ] All required sections are present: Goal, Scope, Phases, Open Questions, Risks & Mitigations.\n- [ ] Mermaid diagrams are included where they add clarity.\n\nOutput Format \u2014 return EXACTLY this structure:\n\nreview_result: <pass|fail>\n\nfailed_items:\n- <checklist item>: <what is wrong and what needs to change>\n...\n\npassed_items_count: <number>\nfailed_items_count: <number>\n\nIf all items pass, return:\nreview_result: pass\nfailed_items: none\npassed_items_count: <number>\nfailed_items_count: 0\n\nProhibited: write_file, run_terminal_cmd, read_ticket, code_search, read_file, git commands\n```\n\n**After Reviewer returns:**\n\n- If `review_result: pass` \u2192 proceed to Step 5.\n- If `review_result: fail` \u2192 pass the full list of failed items back to the **Architect** for revision:\n\n```\nYou are acting as a Software Architect.\n\nYour previous design draft had the following issues identified by the Reviewer. Revise the design to address every item below.\n\nReview feedback:\n<paste full list of failed_items here>\n\nPrevious design:\n<paste full Architect output here>\n\nContext \u2014 Analyst findings:\n<paste full Analyst output here>\n\nContext \u2014 Technical Explorer findings:\n<paste full Technical Explorer output here>\n\nRequirements:\n- Address every failed item listed above.\n- Keep all parts of the design that passed review unchanged.\n- The output format is the same as before \u2014 must begin with `### Proposed Design`.\n\nAllowed tools: code_search, read_file, list_directory (for additional verification only)\nProhibited: write_file, run_terminal_cmd, read_ticket, git commands\n```\n\nAfter the Architect revises, delegate to the **Reviewer** again for a second check. Max 2 review iterations \u2014 if the second review still fails, use the latest Architect output as the final design.\n\n---\n\n## Step 5 \u2014 Final Output\n\nUse the `task_completed` tool to return the final design document (the latest Architect output).\n\nThe output MUST be the design document only \u2014 beginning with `### Proposed Design`.\n\n---\n\n## Example Output\n\n\\`\\`\\`markdown\n### Proposed Design\n\n## Goal\n\nThe goal of this design is to introduce a user preferences update endpoint that integrates with the existing controller-service-repository architecture. The endpoint will follow the same validation and persistence patterns used by the profile module, reusing existing infrastructure rather than introducing new dependencies. Key decision: extend the existing `user.repository.ts` rather than creating a separate preferences repository, since preferences are tightly coupled to the user entity.\n\n## Scope\n\n**In scope:**\n- New `PATCH /users/:id/preferences` endpoint with validation\n- Service-layer logic for partial preference updates with optimistic locking\n- Repository method for persisting preference fields\n- DI registration for new service and repository references\n\n**Out of scope:**\n- Preference change notifications (see PROJ-456)\n- Preferences admin UI (see PROJ-789)\n- Rate limiting for preference updates (see PROJ-460)\n\n## Phase 1 - Add API Endpoint\n\n1. Create a new controller method `updatePreferences` in `src/controllers/userPreferences.controller.ts`, following the pattern in `src/controllers/profile.controller.ts`.\n2. Add a new route entry in `src/routes/userPreferences.routes.ts` pointing to the new controller method.\n3. Reuse the existing validation middleware pattern from `src/controllers/profile.controller.ts` to validate the incoming payload.\n4. Ensure the controller delegates to the service layer without embedding business logic \u2014 edge case: handle partial updates where only some preference fields are provided.\n\n## Phase 2 - Implement Service Logic\n\n1. Add a new method `updateUserPreferences` in `src/services/userPreferences.service.ts`, following the update pattern in `profile.service.ts`.\n2. Load the current user record, apply only the fields defined in the requirements, and return a normalized DTO.\n3. Edge case: handle concurrent preference updates \u2014 use optimistic locking consistent with existing patterns in the user module.\n\n## Phase 3 - Repository and Data Layer Updates\n\n1. Add a new repository method in `src/repositories/user.repository.ts` for saving updated preference fields.\n2. Follow naming conventions from `src/repositories/profile.repository.ts`.\n3. Confirm that only the required fields are persisted and no unrelated data is modified.\n\n## Phase 4 - Wire Up Dependency Configuration\n\n1. Register the new service and repository references in `src/config/container.ts`, following the pattern used for profile and settings components.\n2. Verify the dependency chain resolves correctly at startup.\n\n## Open Questions\n\n- Should preference changes trigger a notification to the user (email/webhook)?\n- Are there rate-limiting requirements for preference updates?\n\n## Risks & Mitigations\n\n- **Data migration**: Existing users have no preferences record \u2014 mitigate by defaulting to empty preferences on first read.\n- **Cache invalidation**: If user data is cached, preference updates must invalidate the cache \u2014 mitigate by reusing the existing cache invalidation pattern in `profile.service.ts`.\n\\`\\`\\`\n\n## Constraints\n\n- Do **not** reply to the user yet.\n- Do **not** add results back to the ticket.\n- Follow the project's architecture and coding standards strictly.\n- Review similar implementations in the repo before designing.\n- Do not introduce new packages, libraries, or external dependencies unless explicitly required by the ticket. If you believe such an addition is required, mark it as \"new dependency\".\n- Focus on functional changes only \u2014 no test or documentation plans.\n- Do not write code. Focus on the design and approach.\n- Only return the completed Markdown document as the final output."
        },
        {
          "id": "identify-repos",
          "name": "Identify Repositories",
          "action": "repo.identify",
          "params": {
            "maxResults": 3,
            "minConfidence": 0.2
          },
          "instruction": null
        },
        {
          "id": "post-design",
          "name": "Post Design & Open Session",
          "action": "agent.session",
          "params": {
            "goal": "Help the user with their questions",
            "agentIds": [
              "cme5km2d40007bf6twhwvz27n"
            ],
            "exitCriteria": {
              "timeLimit": {
                "maxDurationMinutes": 120
              },
              "userSignals": {
                "explicit": [
                  "/done"
                ]
              }
            },
            "listenToComments": true,
            "keepSessionOpenForComments": true
          },
          "instruction": "You are the **Coordinator Agent**.  \nYour responsibility is to handle the post-processing of the generated design document.  \n\n### Process  \n1. Take the Markdown design content produced in the previous step.  \n2. Use `add_comment_to_ticket` to post it as a comment on the issue.  \n   - Append the note:  \n     > If you'd like a draft implementation branch, comment `/pr`.  \n3. Use `update_ticket` to assign the issue to its creator (`{{trigger.issue.user.login}}`).  \n4. Check the \"Open Questions\" section of the design:  \n   - If any open questions exist \u2192 add the label `design-needs-feedback`.  \n   - Otherwise \u2192 add the label `design-complete`.  \n\n### Constraints  \n- Ensure only one final comment is added (idempotent).  \n- Do not modify or truncate the generated Markdown content.  \n- Always append the `/pr` note at the end of the comment."
        }
      ],
      "triggers": [
        {
          "event": "issue_labeled",
          "settings": null,
          "conditions": {
            "field": null,
            "rules": [
              {
                "field": "context.trigger.label",
                "rules": null,
                "value": "needs-design",
                "operator": "equals",
                "combinator": null
              }
            ],
            "value": null,
            "operator": null,
            "combinator": "and"
          },
          "schedule": null
        },
        {
          "event": "manual",
          "slashCommand": {
            "command": "design",
            "requireMention": false
          }
        }
      ],
      "version": "1.0.0",
      "priority": 3,
      "timeoutMs": null
    }
  },
  "refs": {
    "agents": [
      {
        "id": "cme5kh6qv0004bf6t8802o7ul",
        "name": "Technical Writer"
      },
      {
        "id": "cme5khhdh0005bf6tfd9jo4ae",
        "name": "Senior Developer"
      },
      {
        "id": "cme5km2d40007bf6twhwvz27n",
        "name": "Product Manager"
      }
    ]
  }
}
